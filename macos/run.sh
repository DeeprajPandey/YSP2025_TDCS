#!/usr/bin/env bash

# ARG_OPTIONAL_BOOLEAN([update],[u],[Update existing tools without installing core dependencies])
# ARG_HELP([This script automates the setup of a MacOS environment for hardware workshop. By default it installs Xcode tools, Homebrew, Python tools, and clones the workshop repository. Use --update to skip core dependency installation.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info
# Generated online by https://argbash.dev/generate


# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
	local first_option all_short_options='uh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_update="off"


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
	printf '%s\n' "This script automates the setup of a MacOS environment for hardware workshop. By default it installs Xcode tools, Homebrew, Python tools, and clones the workshop repository. Use --update to skip core dependency installation."
	printf 'Usage: %s [-u|--(no-)update] [-h|--help]\n' "$0"
	printf '\t%s\n' "-u, --update, --no-update: Update existing tools without installing core dependencies (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


# The parsing of the command-line
parse_commandline()
{
	local _key
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# The update argurment doesn't accept a value,
			# we expect the --update or -u, so we watch for them.
			-u|--no-update|--update)
				_arg_update="on"
				test "${1:0:5}" = "--no-" && _arg_update="off"
				;;
			# We support getopts-style short arguments clustering,
			# so as -u doesn't accept value, other short options may be appended to it, so we watch for -u*.
			# After stripping the leading -u from the argument, we have to make sure
			# that the first character that follows corresponds to a short option.
			-u*)
				_arg_update="on"
				_next="${_key##-u}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-u" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--update' to see what's going on here - principle is the same.
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option '-u' to see what's going on here - principle is the same.
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Argbash workaround for square brackets:
# https://web.archive.org/web/20230927170347/https://argbash.readthedocs.io/en/latest/#limitations
GREEN='\033[0;32m'    # match square bracket for argbash: ]
YELLOW='\033[1;33m'   # match square bracket for argbash: ]
RED='\033[0;31m'      # match square bracket for argbash: ]
NC='\033[0m'          # match square bracket for argbash: ]

# Track failures
declare -a FAILURES=()

log_info() {
    echo -e "${YELLOW}[INFO] $1${NC}"
}

log_success() {
    echo -e "${GREEN}[SUCCESS] $1${NC}"
}

log_error() {
    echo -e "${RED}[ERROR] $1${NC}"
    FAILURES+=("$1")
}

# Function to check if a command exists in PATH
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to find and setup Homebrew
setup_homebrew_path() {
    if command_exists brew; then
        return 0
    fi

    # Check common Homebrew locations
    if [ -x "/opt/homebrew/bin/brew" ]; then
        log_info "Found Homebrew at /opt/homebrew/bin/brew (Apple Silicon)"
        eval "$(/opt/homebrew/bin/brew shellenv)"
        return 0
    elif [ -x "/usr/local/bin/brew" ]; then
        log_info "Found Homebrew at /usr/local/bin/brew (Intel)"
        eval "$(/usr/local/bin/brew shellenv)"
        return 0
    fi

    return 1
}

# Function to check if VS Code is installed
is_vscode_installed() {
    [ -d "/Applications/Visual Studio Code.app" ]
}

# Function to setup VS Code command line tool
setup_vscode_cli() {
    if command_exists code; then
        return 0
    fi

    local vscode_path="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
    if [ -f "$vscode_path" ]; then
        log_info "VS Code found but 'code' command not in PATH. Adding it..."
        # Add to current session
        export PATH="$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"
        # Try to add permanently (this might need sudo)
        if ln -sf "$vscode_path" /usr/local/bin/code 2>/dev/null; then
            log_success "Added 'code' command to PATH"
        else
            log_info "Could not add 'code' to PATH permanently. For this session only."
            log_info "To add permanently, run: sudo ln -sf '$vscode_path' /usr/local/bin/code"
        fi
        return 0
    fi
    return 1
}

# Function to detect Python installation
detect_python() {
    # Check for any Python 3 (prioritize non-system Python)
    local python_cmd=""

    # Check common Python commands
    for cmd in python3 python; do
        if command_exists "$cmd"; then
            local python_path=$("$cmd" -c "import sys; print(sys.executable)" 2>/dev/null)
            if [ -n "$python_path" ] && [[ "$python_path" != "/usr/bin/python"* ]]; then
                python_cmd="$cmd"
                log_info "Found Python at: $python_path"
                break
            fi
        fi
    done

    # If only system Python found, we need to install Homebrew Python
    if [ -z "$python_cmd" ]; then
        if command_exists python3; then
            local python_path=$(python3 -c "import sys; print(sys.executable)" 2>/dev/null)
            if [[ "$python_path" == "/usr/bin/python"* ]]; then
                log_info "Only system Python found. Will install Homebrew Python."
                return 1
            fi
        else
            log_info "No Python installation found. Will install Homebrew Python."
            return 1
        fi
    fi

    echo "$python_cmd"
    return 0
}

install_core_dependencies() {
    log_info "Setting up core dependencies..."

    # Install Xcode Command Line Tools
    if ! xcode-select -p &>/dev/null; then
        log_info "Installing Xcode Command Line Tools..."
        log_info "A dialog will appear. Please click 'Install' and wait for the installation to complete."
        xcode-select --install 2>/dev/null

        # Wait for installation
        while ! xcode-select -p &>/dev/null; do
            sleep 5
        done
        log_success "Xcode Command Line Tools installed."
    else
        log_info "Xcode Command Line Tools already installed."
    fi

    # Setup Homebrew
    if ! setup_homebrew_path; then
        log_info "Homebrew not found. Installing..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

        # Setup path for current session
        setup_homebrew_path

        if command_exists brew; then
            log_success "Homebrew installed."
        else
            log_error "Failed to install Homebrew"
            return 1
        fi
    else
        log_info "Homebrew already installed."
    fi

    # Update Homebrew
    if command_exists brew; then
        log_info "Updating Homebrew..."
        brew update
    fi
}

setup_environment_and_shell() {
    log_info "Installing packages from Brewfile..."

    # Check if VS Code is already installed via DMG
    if is_vscode_installed; then
        log_info "VS Code already installed in /Applications. Skipping brew installation."
        # Create a temporary Brewfile without VS Code
        grep -v "visual-studio-code" ./Brewfile > ./Brewfile.tmp
        brew bundle --file ./Brewfile.tmp
        rm ./Brewfile.tmp
    else
        # Install everything from Brewfile
        brew bundle --file ./Brewfile
    fi

    # Setup VS Code CLI if needed
    setup_vscode_cli

    # Install VS Code extensions if code command is available
    if command_exists code; then
        log_info "Installing VS Code extensions..."
        code --install-extension ms-python.python
        code --install-extension ms-python.vscode-pylance
        code --install-extension ms-toolsai.jupyter
        code --install-extension ms-vscode.vscode-serial-monitor
    else
        log_error "Could not install VS Code extensions - 'code' command not available"
    fi

    log_success "Environment setup completed."
}

install_python_tools() {
    log_info "Setting up Python and Jupyter tools..."

    # Detect existing Python
    local python_cmd=$(detect_python)

    if [ -z "$python_cmd" ]; then
        # Need to install Python via Homebrew
        log_info "Installing Python via Homebrew..."
        brew install python@3.12 ipython
        python_cmd="python3"
    else
        log_info "Using existing Python installation: $python_cmd"
        # Still install ipython via brew if not present
        if ! command_exists ipython; then
            brew install ipython
        fi
    fi

    # Install ipykernel
    if command_exists "$python_cmd"; then
        log_info "Installing ipykernel..."
        "$python_cmd" -m pip install --user ipykernel
        if [ $? -eq 0 ]; then
            log_success "ipykernel installed successfully."
        else
            log_error "Failed to install ipykernel"
        fi
    else
        log_error "Python not found after installation attempt"
    fi
}

# Main execution
if [ "$_arg_update" = "on" ]; then
    setup_homebrew_path
    setup_environment_and_shell
else
    # Default install behavior
    install_core_dependencies
    setup_environment_and_shell
    install_python_tools
fi

# Clone repository
log_info "Cloning YSP_Day1 repository..."
if git clone https://github.com/tushara04/YSP_Day1.git 2>/dev/null; then
    log_success "Repository cloned."
else
    if [ -d "YSP_Day1" ]; then
        log_info "Repository already exists. Pulling latest changes..."
        cd YSP_Day1 && git pull && cd ..
    else
        log_error "Failed to clone repository"
    fi
fi

# Open VS Code
if [ -d "YSP_Day1/notebooks" ]; then
    cd YSP_Day1/notebooks || {
        log_error "Could not navigate to notebooks directory"
    }

    if command_exists code; then
        log_info "Opening Visual Studio Code..."
        code .
        log_success "VS Code opened in notebooks directory."
    elif is_vscode_installed; then
        log_info "Opening VS Code via open command..."
        open -a "Visual Studio Code" .
        log_success "VS Code opened in notebooks directory."
    else
        log_error "VS Code not available"
    fi
else
    log_error "notebooks directory not found"
fi

# Report any failures
if [ ${#FAILURES[@]} -gt 0 ]; then
    echo
    log_error "The following errors occurred during setup:"
    for failure in "${FAILURES[@]}"; do
        echo "  - $failure"
    done
    echo
    log_info "Please address these issues and run the script again if needed."
else
    echo
    log_success "Setup completed successfully!"
fi

# ] <-- needed because of Argbash
